/* 
 * Based on the unique keys of each slot generated by unique_keys.out
 * Preprocess the raw dataset:
 * 1. for 13 dense feature, do log scale and transfer to float
 * 2. for 26 sparse feature, do remap
 * Should be run after step_1_unique_keys.out
 */

#include "iostream"
#include <cmath>
#include <fstream>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h> 
#include <math.h>
#include <assert.h>
#include <cstddef>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <map>
#include <set>
#include <string>
#include <time.h>
#include <string.h>
#include <unistd.h>

#define FILE_NUM 24
#define DENSE_NUM 13
#define SLOT_BASE 14
#define SLOT_NUM 26
#define SLOT_MASK(s) (1 << (s - SLOT_BASE))

using namespace std;
char *input_dir, *output_dir, *key_dir;

class Mapping {
private:
    map<uint32_t, uint32_t> *slot_cat_mappings[SLOT_NUM];
    uint32_t max_cat;
public:
    Mapping() {
        max_cat = 1;
        for (int i = 0; i < SLOT_NUM; i++) construct_slot(i);
    }

    ~Mapping() {
        for (int i = 0; i < SLOT_NUM; i++) delete slot_cat_mappings[i]; 
    }

    void construct_slot(int slot_no) {
        clock_t start = clock();
        std::string fname = std::string(key_dir) + "slot_" + std::to_string(slot_no);
        slot_cat_mappings[slot_no] = new map<uint32_t, uint32_t>;

        // get file size
        struct stat statbuf;  
        stat(fname.c_str(), &statbuf);  
        size_t size = statbuf.st_size;
        assert((size % sizeof(uint32_t)) == 0);

        // open and mmap file
        int fd = open(fname.c_str(), O_RDONLY);
        assert(fd != -1);
        char *data = (char *) mmap( NULL, size ,PROT_READ, MAP_PRIVATE, fd, 0);

        // read and parse file
        uint32_t *cats = (uint32_t *)data;
        size_t cnt = size / sizeof(uint32_t);
        for (size_t i = 0; i < cnt; i++) 
            (*slot_cat_mappings[slot_no])[cats[i]] = max_cat++;
        (*slot_cat_mappings[slot_no])[0] = max_cat++;

        // munmap and close file
        munmap(data, size);
        close(fd);
        printf("Construct slot %d with %ld categories using %g s.\n", slot_no, cnt, (double(clock() - start) / CLOCKS_PER_SEC));
    }

    uint32_t at(int slot_no, uint32_t old_cat) {return slot_cat_mappings[slot_no]->at(old_cat);}
};

Mapping *cat_mapping;

bool read_label(char * &ptr, size_t &remain_bytes) {
    char value = *ptr;
    if ((value != '1' && value != '0') || ptr[1] != '\t') assert(false);

    remain_bytes -= 2;
    ptr += 2;
    if (value == '1') return true;
    else return false;
}

uint32_t read_int(char * &ptr, size_t &remain_bytes) {
    // fill missing
    if (!remain_bytes) return 0;
    if (*ptr == '\t') {
        remain_bytes --;
        ptr ++;
        return 0;
    }

    // read hex
    char *tail = NULL;
    long res = strtol(ptr, &tail, 10);
    assert((tail - ptr) > 0);

    remain_bytes -= (1 + tail - ptr);
    ptr = (1 + tail);
    // printf("\tread int %u\n", static_cast<uint32_t>(res));
    return static_cast<uint32_t>(res);

    // get integar str size
    // size_t sz = 0;
    // while (sz < remain_bytes && ptr[sz] != '\t') sz++;
    // remain_bytes -= (sz + 1);

    // if (sz == 0) return 0; // fill missing
    // else return atoi(ptr);
}

uint32_t read_hex(char * &ptr, size_t &remain_bytes) {
     // fill missing
    if (!remain_bytes) return 0;
    if (*ptr == '\t' || *ptr == '\n') {
        remain_bytes --;
        ptr ++;
        return 0;
    }

    // read hex
    char *tail = NULL;
    long res = strtol(ptr, &tail, 16);
    assert((tail - ptr) == 8);

    remain_bytes -= 9;
    ptr = (1 + tail);
    // printf("\tread hex %u\n", static_cast<uint32_t>(res));
    return static_cast<uint32_t>(res);
}

void transform_sample(ofstream *ofile, uint32_t *sample) {
    // label
    ofile->write((char *)sample, sizeof(uint32_t));

    // integer values
    for (int i = 0; i < DENSE_NUM; i++) {
        float val = static_cast<float>(log(sample[1 + i] + 1));
        ofile->write((char *)&val, sizeof(float));
    }

    // categories
    for (int i = 0; i < SLOT_NUM; i++) {
        uint32_t new_val = cat_mapping->at(i, sample[SLOT_BASE + i]);
        ofile->write((char *)&new_val, sizeof(uint32_t));
        // if (!old_val) ofile->write((char*)&old_val, sizeof(uint32_t));
        // else {
        //     uint32_t new_val = cat_mapping->at(i, old_val);
        //     ofile->write((char *)&new_val, sizeof(uint32_t));
        // }
    }
}

void transform_file(const char * ifname, const char * ofname) {
    printf("Transfer file %s to %s ...\n", ifname, ofname);
    clock_t start = clock();

    // get input file size
    struct stat statbuf;  
    stat(ifname, &statbuf);  
    size_t size = statbuf.st_size;  

    // open and mmap input file
    int fd = open(ifname, O_RDONLY);
    assert(fd != -1);
    char *data = (char *) mmap( NULL, size ,PROT_READ, MAP_PRIVATE, fd, 0);

    // open output file
    ofstream ofile(ofname, ofstream::out | ofstream::trunc);

    // read and parse file
    char *read_ptr = data;
    size_t remain_bytes = size, sample_no = 0;
    uint32_t sample[40];
    while (remain_bytes > 2) {
        sample[0] = read_label(read_ptr, remain_bytes);
        for (int i = 1; i < 14; i++) sample[i] = read_int(read_ptr, remain_bytes);
        for (int i = 14; i < 40; i++) sample[i] = read_hex(read_ptr, remain_bytes);

        transform_sample(&ofile, sample);
        sample_no++;
        if ((sample_no % 10000000) == 0) 
            printf("\t %ld samples in file %s using %g s\n", sample_no, ifname, (double(clock() - start) / CLOCKS_PER_SEC));
    }

    // munmap and close file
    munmap(data, size);
    close(fd);
    printf("Total samples in file %s: %ld, %g seconds used.\n", ifname, sample_no, (double(clock() - start) / CLOCKS_PER_SEC));
}


int main(int argc, char *argv[]) {
    // input arguments
    assert(argc > 4);
    input_dir = argv[1];            // the input directory, e.g. /disk1/criteo-TB/raw/
    output_dir = argv[2];           // the output directory, e.g. /disk1/criteo-TB/processed/
    key_dir = argv[3];              // the unique key directory, which contains the output of step 1, e.g. /disk1/criteo-TB/unique_keys/
    int file_num = argc - 4;        // the rest are input raw data file names
    char **fnames = new char*[file_num];
    for (int i = 0; i < file_num; i++) fnames[i] = argv[i + 4];

    // initialize global key map
    if (file_num > 0) cat_mapping = new Mapping();

    // process each file
    clock_t start = clock();
    for (int i = 0; i < file_num; i++) {
        std::string ifname = std::string(input_dir) + std::string(fnames[i]);
        std::string ofname = std::string(output_dir) + std::string(fnames[i]);
        transform_file(ifname.c_str(), ofname.c_str());
    }
    printf("[Step 2] Replace keys in %d files use %g s.\n", file_num, (double(clock() - start) / CLOCKS_PER_SEC));
}
